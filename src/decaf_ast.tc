%option lang = "C++"
%option reentrant

%decls %{
    #include <string>
    #include <cstddef> //for size_t
    #include <cmath>
    #include <unordered_map>
    #include <vector>
    #include <utility>

    #include "funcdef.h"
    #include "decaf_cfg.h"

    class statement;

    using CFGTuple = std::pair<CFG::Node*, CFG::Node*>;
    using CFGExpr = CFG::Expr*;
    using CFGOP = CFG::Operand*;

    using string_t = std::string;
    using string_v = std::vector<std::string>;
    using map_t = std::unordered_map<std::string, int>;
    using paramv_t = std::vector<statement*>;
    using Func = FuncDef*;
%}

%{
    #include "decaf_ast.h"
    #include <iostream>
    #include <stdio.h>
    void yyerror(const char *msg);

    int label_counter = 0;
    int var_counter = 0;
%}

%enum type_code = 
{
    int_type,
    string_type,
    bool_type,
    void_type
}

%node ASTNode %abstract %typedef = 
{
    %nocreate int value = { 0 };
    %nocreate string_t str_val = { "" };
    %nocreate type_code type = {int_type};
}

%node expression ASTNode %abstract = {}

%node binary expression %abstract = 
{
    expression *expr1;
    expression *expr2;
}

%node unary expression %abstract = {}

%node intnum unary = 
{
    int num;
}

%node str unary =
{
    string_t val;
}

%node id unary =
{
    string_t id_val;
}

%node bool_expr unary =
{
    bool b_val;
}

%node plus binary
%node minus binary
%node multiply binary
%node divide binary
%node less binary
%node greater binary
%node lte binary
%node gte binary
%node equal binary
%node nequal binary

%node statement ASTNode %abstract

%node stmt_block statement = {
    statement * first;
    statement * next;
}

%node ifStmt statement = {
    expression * condition;
    stmt_block * then_s;
    stmt_block * else_s;
}

%node method_declaration statement = {
    type_code t;
    string_t name;
    paramv_t params;
    statement * block;
}

%node param_declaration statement = {
    type_code t;
    string_t name;
}

%node field_declaration statement = {
    type_code t;
    string_v names;
}

%node field_assign statement = {
    type_code t;
    string_t name;
    expression * expr;
}

%node assign statement = {
    string_t id;
    expression * expr;
}

%node while_stmt statement = {
    expression * condition;
    stmt_block * stmt;
}

%node println statement = {
    expression * expr;
}

%node print statement = {
    expression * expr;
}

%node empty_node statement

%operation %virtual void exec(ASTNode *this, map_t & vars)
%operation %virtual void infer_type(expression * this)
%operation %virtual string_t toString(ASTNode * this)
%operation %virtual CFGTuple AST2CFG(statement * this)
%operation %virtual CFGExpr EXPR2CFG(binary * this)
%operation %virtual CFGOP OP2CFG(unary * this)
%operation %virtual Func genFunc(method_declaration * this)
%operation %virtual bool isUnary(expression * this)

isUnary(plus){
    return false;
}
isUnary(minus){
    return false;
}
isUnary(multiply){
    return false;
}
isUnary(divide){
    return false;
}
isUnary(greater){
    return false;
}
isUnary(less){
    return false;
}
isUnary(gte){
    return false;
}
isUnary(lte){
    return false;
}
isUnary(equal){
    return false;
}
isUnary(nequal){
    return false;
}
isUnary(intnum){
    return true;
}
isUnary(str){
    return true;
}
isUnary(id){
    return true;
}
isUnary(bool_expr){
    return true;
}

genFunc(method_declaration){
    CFGTuple t = block->AST2CFG();
    Func f = new FuncDef(name, t);
    return f;
}

AST2CFG(stmt_block){
    CFGTuple f = first->AST2CFG();
    CFGTuple n = next->AST2CFG();

    CFG::SingleEdge * se = new SingleEdge(n.first);
    f.second->setEdge(se);
    return std::make_pair(f.first, n.second);
}

AST2CFG(method_declaration){}

AST2CFG(println){
    CFG::Node * n = new CFG::Node();
    if(expr->isUnary()){
        unary * u = static_cast<unary*>(expr);
        CFG::Operand * op = u->OP2CFG();
        if(op->getKind() == NodeKind::IntOperand){
            CFG::ParamStatement * par = new CFG::ParamStatement(op);
            CFG::StringOperand * s = new CFG::StringOperand("a%da");
            CFG::ParamStatement * par1 = new CFG::ParamStatement(s);
            n->addStatement(par);
            n->addStatement(par1);
        }
        else{
            CFG::ParamStatement * par = new CFG::ParamStatement(op);
            n->addStatement(par);
        }
    }
    else{
        binary * b = static_cast<binary*>(expr);
        unary * u1 = static_cast<unary*>(b->expr1);
        unary * u2 = static_cast<unary*>(b->expr2);
        CFG::Operand * op1 = u1->OP2CFG();
        CFG::Operand * op2 = u2->OP2CFG();
        CFG::AddExpr * add = new CFG::AddExpr(op1, op2);
        CFG::ExprStatement * e = new CFG::ExprStatement(add);
        CFG::LValueOperand * reg = new CFG::LValueOperand("eax");
        CFG::ParamStatement * par = new CFG::ParamStatement(reg);
        CFG::StringOperand * s = new CFG::StringOperand("a%da");
        CFG::ParamStatement * par1 = new CFG::ParamStatement(s);
        n->addStatement(e);
        n->addStatement(par);
        n->addStatement(par1);
    }

    CFG::CallStatement * call = new CFG::CallStatement("printf", 1);

    std::string lbl = "LBL" + std::to_string(label_counter++);
    n->setLabel(lbl);
    n->addStatement(call);
    CFG::Node * nop = new CFG::Node();
    nop->setLabel("nop");
    nop->setNop();
    n->setEdge(new SingleEdge(nop));
    //std::cout << "println\n";
    return std::make_pair(n, nop);
}

AST2CFG(print){
    CFG::Node * n = new CFG::Node();
    if(expr->isUnary()){
        unary * u = static_cast<unary*>(expr);
        CFG::Operand * op = u->OP2CFG();
        if(op->getKind() == NodeKind::IntOperand){
            CFG::ParamStatement * par = new CFG::ParamStatement(op);
            CFG::StringOperand * s = new CFG::StringOperand("a%da");
            CFG::ParamStatement * par1 = new CFG::ParamStatement(s);
            n->addStatement(par);
            n->addStatement(par1);
        }
        else{
            CFG::ParamStatement * par = new CFG::ParamStatement(op);
            n->addStatement(par);
        }
    }
    else{
        binary * b = static_cast<binary*>(expr);
        unary * u1 = static_cast<unary*>(b->expr1);
        unary * u2 = static_cast<unary*>(b->expr2);
        CFG::Operand * op1 = u1->OP2CFG();
        CFG::Operand * op2 = u2->OP2CFG();
        CFG::AddExpr * add = new CFG::AddExpr(op1, op2);
        CFG::ExprStatement * e = new CFG::ExprStatement(add);
        CFG::LValueOperand * reg = new CFG::LValueOperand("eax");
        CFG::ParamStatement * par = new CFG::ParamStatement(reg);
        CFG::StringOperand * s = new CFG::StringOperand("a%da");
        CFG::ParamStatement * par1 = new CFG::ParamStatement(s);
        n->addStatement(e);
        n->addStatement(par);
        n->addStatement(par1);
    }

    CFG::CallStatement * call = new CFG::CallStatement("printf", 1);

    std::string lbl = "LBL" + std::to_string(label_counter++);
    n->setLabel(lbl);
    n->addStatement(call);
    CFG::Node * nop = new CFG::Node();
    nop->setLabel("nop");
    nop->setNop();
    n->setEdge(new SingleEdge(nop));
    //std::cout << "println\n";
    return std::make_pair(n, nop);
}

OP2CFG(intnum){
    CFG::IntOperand * ret = new CFG::IntOperand(num);
    return ret;
}

OP2CFG(str){
    CFG::StringOperand * ret = new CFG::StringOperand(val);
    return ret;
}

OP2CFG(id){
    CFG::IDOperand * ret = new CFG::IDOperand(id_val);
    return ret;
}
OP2CFG(bool_expr){
    CFG::BoolOperand * ret = new CFG::BoolOperand(b_val);
    return ret;
}

EXPR2CFG(plus){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::AddExpr * add = new CFG::AddExpr(op1, op2);
    return add;
}
EXPR2CFG(minus){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::SubExpr * sub = new CFG::SubExpr(op1, op2);
    return sub;
}
EXPR2CFG(multiply){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::MultExpr * mul = new CFG::MultExpr(op1, op2);
    return mul;
}
EXPR2CFG(divide){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::DivExpr * div = new CFG::DivExpr(op1, op2);
    return div;
}
EXPR2CFG(greater){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::GreaterExpr * g = new CFG::GreaterExpr(op1, op2);
    return g;
}
EXPR2CFG(less){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::LessExpr * less = new CFG::LessExpr(op1, op2);
    return less;
}
EXPR2CFG(gte){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::GTEExpr * gte = new CFG::GTEExpr(op1, op2);
    return gte;
}
EXPR2CFG(lte){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::LTEExpr * lte = new CFG::LTEExpr(op1, op2);
    return lte;
}
EXPR2CFG(equal){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::EqualExpr * equal = new CFG::EqualExpr(op1, op2);
    return equal;
}
EXPR2CFG(nequal){
    CFG::Operand * op1;
    CFG::Operand * op2;
    if(expr1->isUnary()){
        unary * u1 = static_cast<unary*>(expr1);
        op1 = u1->OP2CFG();
    }
    if(expr2->isUnary()){
        unary * u2 = static_cast<unary*>(expr2);
        op2 = u2->OP2CFG();
    }
    CFG::NequalExpr * nequal = new CFG::NequalExpr(op1, op2);
    return nequal;
}
AST2CFG(ifStmt){}
AST2CFG(param_declaration){}
AST2CFG(field_assign){}
AST2CFG(field_declaration){}
AST2CFG(assign){}
AST2CFG(while_stmt){}
AST2CFG(empty_node){
    CFG::Node * nop = new CFG::Node();
    nop->setLabel("nop");
    nop->setNop();

    CFG::Node * nop1 = new CFG::Node();
    nop->setLabel("nop");
    nop->setNop();

    return std::make_pair(nop, nop1);
}

toString(intnum){
    return std::to_string(num);
}

toString(str){
    return val;
}

toString(id){
    return id_val;
}

toString(bool_expr){
    return b_val ? "1" : "0";
}

toString(plus){
    return expr1->toString() + "+" + expr2->toString();
}
toString(minus){
    return expr1->toString() + "-" + expr2->toString();
}
toString(multiply){
    return expr1->toString() + "*" + expr2->toString();
}
toString(divide){
    return expr1->toString() + "/" + expr2->toString();
}
toString(less){
    return expr1->toString() + "<" + expr2->toString();
}
toString(greater){
    return expr1->toString() + ">" + expr2->toString();
}
toString(lte){
    return expr1->toString() + "<=" + expr2->toString();
}
toString(gte){
    return expr1->toString() + ">=" + expr2->toString();
}
toString(equal){
    return expr1->toString() + "==" + expr2->toString();
}
toString(nequal){
    return expr1->toString() + "!=" + expr2->toString();
}

toString(stmt_block){
    return first->toString() + "\n" +  next->toString();
}
toString(ifStmt){
    return ("if(" + condition->toString() + ")\n" + "{\n" + then_s->toString() + "\n}\n" + "else {\n" + else_s->toString() + "\n}\n" );
}
toString(method_declaration){
    std::string tp;
    if(t == int_type) { tp = "int"; } 
    else if(t == bool_type ){ tp = "bool"; }
    else { tp = "void"; }

    std::string params_s;
    for(int i = 0; i < params.size(); i++){
        params_s += params.at(i)->toString();
    }

    return (tp + " " + name + "(" + params_s + "){\n" + block->toString() + "}\n");
}
toString(param_declaration){
    std::string tp;
    if(t == int_type) { tp = "int"; } else { tp = "bool"; }

    return tp + " " + name;
}

toString(field_assign){
    std::string tp;
    if(t == int_type) { tp = "int"; } else { tp = "bool"; }

    return tp + " " + name + " " + expr->toString();
}

toString(field_declaration) {
    std::string tp;
    if(t == int_type) { tp = "int"; } else { tp = "bool"; }

    std::string decl_s;
    for(int i = 0; i < names.size(); i++){
        decl_s += names.at(i);
        decl_s += " ";
    }

    return tp + " " + decl_s + ";";
}

toString(assign){
    return id + " " + expr->toString();
}

toString(while_stmt){
    return ("while(" + condition->toString() + "){\n" + stmt->toString() + "\n}");
}

toString(println){
    return ("System.out.println(" + expr->toString() + ")" );
}

toString(print){
    return ("System.out.print(" + expr->toString() + ")" );
}
toString(empty_node){
    return "";
}

infer_type(str){
    type = {string_type};
}

infer_type(intnum){
    type = {int_type};
}

infer_type(plus){
    type = {int_type};
}

infer_type(minus){
    type = {int_type};
}

infer_type(multiply){
    type = {int_type};
}

infer_type(divide){
    type = {int_type};
}

infer_type(less){
    type = {int_type};
}

infer_type(greater){
    type = {int_type};
}

infer_type(lte){
    type = {int_type};
}

infer_type(gte){
    type = {int_type};
}

infer_type(equal){
    type = {int_type};
}

infer_type(nequal){
    type = {int_type};
}

infer_type(id){
}

exec(empty_node){

}

exec(stmt_block){
    first->exec(vars);
    next->exec(vars);
}

exec(println){
    expr->exec(vars);
    expr->infer_type();
    if(expr->type == int_type)
        std::cout << expr->value << std::endl;
    else{
        expr->str_val.erase(0,1);
        expr->str_val.erase(expr->str_val.size() - 1);
        std::cout << expr->str_val << std::endl;
    }
}

exec(print){
    expr->exec(vars);
    expr->infer_type();
    if(expr->type == int_type)
        std::cout << expr->value;
    else{
        expr->str_val.erase(0,1);
        expr->str_val.erase(expr->str_val.size() - 1);
        std::cout << expr->str_val;
    }
}

exec(ifStmt){
    condition->exec(vars);
    if(condition->value){
        then_s->exec(vars);
    }
    else{
        else_s->exec(vars);
    }
}

exec(while_stmt){
    condition->exec(vars);
    while(condition->value){
        stmt->exec(vars);
        condition->exec(vars);
    }
}

exec(assign){
    expr->exec(vars);
    vars[id] = expr->value;
}

exec(plus){
    expr1->exec(vars);
    expr2->exec(vars);
    value = expr1->value + expr2->value;
}

exec(minus){
    expr1->exec(vars);
    expr2->exec(vars);
    value = expr1->value - expr2->value;
}

exec(multiply){
    expr1->exec(vars);
    expr2->exec(vars);
    value = expr1->value * expr2->value;
}

exec(divide){
    expr1->exec(vars);
    expr2->exec(vars);
    value = expr1->value / expr2->value;
}

exec(less){
    expr1->exec(vars);
    expr2->exec(vars);
    value = expr1->value < expr2->value;
}

exec(greater){
    expr1->exec(vars);
    expr2->exec(vars);
    value = expr1->value > expr2->value;
}

exec(gte){
    expr1->exec(vars);
    expr2->exec(vars);
    value = expr1->value >= expr2->value;
}

exec(lte){
    expr1->exec(vars);
    expr2->exec(vars);
    value = expr1->value <= expr2->value;
}

exec(equal){
    expr1->exec(vars);
    expr2->exec(vars);
    value = (expr1->value == expr2->value);
}

exec(nequal){
    expr1->exec(vars);
    expr2->exec(vars);
    value = (expr1->value != expr2->value);
}

exec(intnum){
    value = num;
}

exec(id){
    value = vars[id_val];
}

exec(str){
    str_val = val;
}

exec(method_declaration){}
exec(bool_expr){}
exec(field_assign){}
exec(field_declaration){}
infer_type(bool_expr) {}
exec(param_declaration){}